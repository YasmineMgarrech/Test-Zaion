<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>test-zaion</title><meta name="description" content="Documentation for test-zaion"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">test-zaion</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1> test-zaion</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#calcul-de-surface-d39eau-maximale-stockée-entre-les-batiments" id="calcul-de-surface-d39eau-maximale-stockée-entre-les-batiments" style="color: inherit; text-decoration: none;">
  <h1>Calcul de surface d&#39;eau maximale stockée entre les batiments</h1>
</a>

<a href="#la-logique" id="la-logique" style="color: inherit; text-decoration: none;">
  <h2><em>La logique</em></h2>
</a>
<p>Pour aborder cette question, nous devons d&#39;abord comprendre le phénomène des bâtiments qui retiennent l&#39;eau.</p>
<p>Un bâtiment ne peut retenir l&#39;eau que lorsqu&#39;il y a des bâtiments plus élevés à sa gauche et à sa droite car l&#39;eau sera piégée entre ces 2 bâtiments.</p>
<p>On peut donc facilement en déduire que la quantité d&#39;eau qu&#39;un bloc peut contenir est égale au minimum de la hauteur maximale présente sur les moitiés gauche et droite moins la hauteur du bloc actuel.</p>

<a href="#algorithm" id="algorithm" style="color: inherit; text-decoration: none;">
  <h2>Algorithm</h2>
</a>
<p>Pour résoudre ce problème de manière programmatique, nous allons représenter les hauteurs des bâtiments comme un tableau contenant dans le même ordre que les bâtiments la hauteur correspondante.</p>

<a href="#solution-simple" id="solution-simple" style="color: inherit; text-decoration: none;">
  <h3>Solution simple</h3>
</a>
<p>La façon la plus simple de trouver les bâtiments les plus hauts à gauche et à droite de chaque bâtiment et de calculer la surface d&#39;eau piégée comme décrit ci-dessus, nous devons parcourire le tableau et à chaque fois parcourire le tableau à nouveau deux fois en gardant la valeur de la hauteur du bâtiment actuel, pour trouver la hauteur maximale à droite et à gauche.</p>

<a href="#compléxité" id="compléxité" style="color: inherit; text-decoration: none;">
  <h3>Compléxité</h3>
</a>
<p>Dans cette solution, nous avons un ensemble d&#39;instructions et 3 boucles (2 d&#39;entre elles sont imbriquées). La complexité temporelle est donc O(n²), avec n la taille de tableau (nombre des batiments). Et la complexité spaciale est O(1) car nous avons pas besoin d&#39;un espace extra.</p>

<a href="#solution-optimale" id="solution-optimale" style="color: inherit; text-decoration: none;">
  <h2>Solution Optimale</h2>
</a>
<p>La première solution est simple, elle fait l&#39;affaire, mais elle n&#39;est pas optimale. Pour la rendre optimale, nous devons donc traverser le tableau une seule fois. Pour ce faire, un outil toujours utilisé lorsque nous devons rechercher une paire de valeurs dans un tableau sans utiliser de tableaux imbriqués est d&#39;utiliser deux pointeurs.</p>
<p>Nous désignons deux pointeurs indexL et indexR à partir de deux extrémités du tableau. Et nous nous conservons à chaque fois les valeurs de batiments max à droite (rightMax) et à gauche (leftMax).
Si le leftMax actuel est inférieur au rightMax, nous pouvons calculer correctement l&#39;eau à indexL, mais pas l&#39;eau à indexR.</p>
<p>Examinons le cas où leftMax &lt; rightMax. Nous supposons que leftMax est l&#39;hauteur d&#39;une batiment situer à gauche de la batiment à indexL.</p>
<p>Puisque leftMax &lt; rightMax, la quantité d&#39;eau à indexL peut être déterminée à ce moment, quelles que soient les hauteurs à droite (car le batiment le plus haut à droit ne peut pas etre inférieur à rightMax). Et la quantité est le max entre  0 et la difference entre leftMax et l&#39;hauteur de notre batiment indexL.</p>
<p>(Meme principe pour rightMax&gt;=leftMax)</p>

<a href="#compléxité-1" id="compléxité-1" style="color: inherit; text-decoration: none;">
  <h3>Compléxité</h3>
</a>
<p>Dans cette solution, nous avons éliminé l&#39;utilisation de boucles imbriqués, On fait un seul parcours donc la compléxité temporelle est O(n) et la compléxité spaciale et encore O(1)</p>

<a href="#cas-de-test" id="cas-de-test" style="color: inherit; text-decoration: none;">
  <h2>Cas de test</h2>
</a>
<p>On utilise POSTMAN pour les tests</p>

<a href="#test-1--tableau-vide" id="test-1--tableau-vide" style="color: inherit; text-decoration: none;">
  <h3>Test 1 : tableau vide</h3>
</a>
<p><img src="" alt=""></p>

<a href="#test-2--tableau-simple" id="test-2--tableau-simple" style="color: inherit; text-decoration: none;">
  <h3>Test 2 : tableau simple</h3>
</a>
<p><img src="" alt=""></p>

<a href="#test-3--tableau-simple" id="test-3--tableau-simple" style="color: inherit; text-decoration: none;">
  <h3>Test 3 : tableau simple</h3>
</a>
<p><img src="" alt=""></p>

<a href="#test-4--tableau-simple" id="test-4--tableau-simple" style="color: inherit; text-decoration: none;">
  <h3>Test 4 : tableau simple</h3>
</a>
<p><img src="" alt=""></p>

<a href="#test-4--tableau-complexe" id="test-4--tableau-complexe" style="color: inherit; text-decoration: none;">
  <h3>Test 4 : tableau complexe</h3>
</a>
<p><img src="" alt=""></p>

<a href="#test-5--tableau-complexe" id="test-5--tableau-complexe" style="color: inherit; text-decoration: none;">
  <h3>Test 5 : tableau complexe</h3>
</a>
<p><img src="" alt=""></p>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Modules</a></li><li class=" tsd-kind-module"><a href="modules/Batiments.html">Batiments</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>